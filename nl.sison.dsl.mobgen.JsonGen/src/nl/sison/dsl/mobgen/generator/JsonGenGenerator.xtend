/*
 * generated by Xtext
 */
package nl.sison.dsl.mobgen.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess


import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import java.util.Map
import java.util.Iterator
import nl.sison.dsl.mobgen.jsonGen.JsonObject
import nl.sison.dsl.mobgen.jsonGen.Member
import nl.sison.dsl.mobgen.jsonGen.JsonValue

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class JsonGenGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {

		// generate Android Parcelable
		val JsonObjects = resource.contents.filter(typeof(JsonObject))
		
		if (!resource.contents.empty)
			for (obj : JsonObjects)
			{
				parseJsonObject("Root", obj, fsa) 
			}
		
		// TODO generate MOBBL Document definition
		
		// TODO generate iOS 
	}

	/**
	 * TODO add mapping of JSONArray
	 */	
	def createJsonParserCtor(CharSequence className, JsonObject jsonRootObject) '''
	public «className»(final JSONObject jsonRoot)
	{
		«FOR member : jsonRootObject.members»
		«IF member.optional»
		if (!jsonRoot.isNull("«member.key»"))
		{
			this.«member.key.camelCase» = «member.mapToSerializedType»
		}
		«ELSE»
		this.«member.key.camelCase» = «member.mapToSerializedType»
		«ENDIF»
		«ENDFOR»
	}
	'''
	
	def mapToSerializedType(Member member)
	{
		val value = member.value
		val key = member.key
		
		if (value.obj != null)
			return String.format("new %s(jsonRoot.getJsonObject());", key.generatedType)
			
		if (value.str != null)
		{
			return String.format("jsonRoot.getString(\"%s\")", key)
		}
		
		// TODO array, number

		if (value.bool) return String.format("jsonRoot.getBoolean(\"%s\")", key)
		
		if(value.float) return String.format("jsonRoot.getDouble(\"%s\")", key)
		if(value.int)	return String.format("jsonRoot.getLong(\"%s\")", key)
		
		return "UNDEFINED"
	}
	
	def void parseJsonObject(CharSequence className, JsonObject jsonRootObject, IFileSystemAccess fsa)
	{
		if (jsonRootObject == null) return;
		
		val map = <String, String>newHashMap()
		
		for (member : jsonRootObject.members)
		{
			val value = member.value
			val key = member.key.camelCase
			
			if (value.obj != null)
			{
				val generatedType = key.generatedType
				parseJsonObject(generatedType, value.obj, fsa)
				map.put(key, generatedType)		
			}
			
			if (value.bool)
			{
				map.put(key, 'boolean') // Parcelable types do not support booleans, TODO test
			}
			
			if (value.str != null && !value.str.empty)
			{
				map.put(key, 'String')
			}
			
			if (value.float)
			{
				map.put(key, "Double") // bigger? BigDecimal
			}
			
			if (value.int)
			{
				map.put(key, "Long") // bigger? BigInteger
			}
				
//			value.number ?: map.put('BigInteger[] or int, prevent over and underflow in any case', member.key) // TODO
//			value.strFromEnum ?: map.put('Parcelable', member.key) // TODO generate enum type, copy paste existing code
//			value.datetime ?: map.put('Date', member.key) // TODO add conversion to int in the serialization process 

			/**
			 * Inspect first object then generalize for the whole list
			 */
//			value.array ?: value.array.values ?: value.array.values.get(0).parseJsonListItem(map, key, fsa)
		}
		
		fsa.generateFile(className + '.java', className.createParcelable(map, className.createJsonParserCtor(jsonRootObject)))
	}
	
	/**
	 * TODO read http://stackoverflow.com/questions/10071502/read-writing-arrays-of-parcelable-objects
	 */
	def parseJsonListItem(JsonValue value, Map<String,String> map, String key, IFileSystemAccess fsa)
	{
		value.obj?:
		{
			parseJsonObject(key.toString.capitalizeFirstLetter, value.obj, fsa)
			map.put('Parcelable[]', key + 's')
		}
		
//		if (value.bool) map.put('boolean[]', key + 's')
//		value.str ?: map.put('String[]', key + 's')
//		value.number ?: map.put('BigInteger[] or int, prevent over and underflow in any case', member.key) // TODO
//		value.strFromEnum ?: map.put('Parcelable[]', member.key) // TODO generate enum type, copy paste existing code
//		value.datetime ?: map.put('int[]', member.key) // TODO add conversion to int in the serialization process 
//		value.array? // TODO multi-dimensional array
		
	}
	
	/**
	 * 
	 * We got, boolean (faked Integer), Integers, Serializables, Parcelables, String, Arrays...
	 * source: http://idlesun.blogspot.nl/2012/12/android-parcelable-example-2-subobject.html
	 *  
	 * Parcelables are actually just POJOs that are faster than Serializables,
	 * only Parcelables require manual work to pass on values from one object to the next
	 *
	 * This type of parcelable contains an Exception field in case of failure along the way
	 * e.g. no internet connection etc.
	 * This implementation is intended to be passed on from the background threads
	 * to the ui thread
	 *
	 */ 
	val acceptedTypes = newLinkedList("String", "Integer", "Long", "Float", "Double")
	def createParcelable(CharSequence parcelableClassName, Map<String,String> members, CharSequence additionalMethodsEtc) '''
	public class «parcelableClassName» extends Parcelable
	{
	    «FOR s : members.entrySet»
	    « s.key.createParcelableProtectedMembers(s.value) »
	    «ENDFOR»
	    
	    protected Exception exception = null;
	    
	    «FOR s : members.entrySet»
	    « s.key.createParcelableAccessors(s.value) »
	    «ENDFOR»

	    public «parcelableClassName»(«members.entrySet.map([t | String.format("final %s %s", t.value, t.key)]).join(', ')»)
	    {
			«FOR s : members.entrySet»
			this.« s.key » = « s.key »; 
			«ENDFOR»
	    }

		public «parcelableClassName»(Exception exception)
		{
			this.exception = exception;
		}
	
		public boolean hasException()
		{
			return exception != null;
		}

	    public «parcelableClassName»(Parcel in) {
	    	readFromParcel(in);
	    }

	    @Override
	    public void writeToParcel(Parcel out, int flags) {
		«FOR s : members.entrySet»
		«IF acceptedTypes.contains(s.value)»
			out.write«s.value»(«s.key»);
		«ELSEIF s.value.equals("boolean")»
			out.writeInteger(«s.key» ? 1 : 0);
		«ELSE»
			out.writeParcelable(«s.key», flags);
		«ENDIF»
		«ENDFOR»
		out.writeSerializable(exception);
	    }

		@Override
	    private void readFromParcel(Parcel in) {
		«FOR s : members.entrySet»
			«IF acceptedTypes.contains(s.value)»
			«s.key» = in.read«s.value»();
			«ELSEIF s.value.equals("boolean")»
			«s.key» = in.readInteger() > 0;
			«ELSE»
			«s.key.createParcelableReadMember(s.value)»
			«ENDIF»
		«ENDFOR»
			exception = (Exception) in.readSerializable();
	    }

	    public static final Parcelable.Creator CREATOR = new Parcelable.Creator() {

	        public «parcelableClassName» createFromParcel(Parcel in) {
	            return new «parcelableClassName»(in);
	        }

	        public «parcelableClassName»[] newArray(int size) {
	            return new «parcelableClassName»[size];
	        }

	    };

	    @Override
	    public int describeContents() {
	        return 0;
	    }
	    
	    «additionalMethodsEtc»
	}
	'''
	
	def joinPairAsMap(Iterator<CharSequence> keys, Iterator<CharSequence> values)
	{
		val hashMap = <CharSequence, CharSequence>newHashMap()
		while (keys.hasNext && values.hasNext)
		{
			val value = values.next
			val key = keys.next
			hashMap.put(key, value)
		}
		return hashMap
	}

	def createParcelableProtectedMembers(CharSequence parameterName, CharSequence parameterType) '''
	protected «parameterType» «parameterName»;
	''' 

	def createParcelableReadMember(String parameterName, CharSequence readMethodNameSuffix) '''
	«parameterName» = in.readParcelable(«parameterName.generatedType».class.getClassLoader());
	'''

	def createParcelableAccessors(CharSequence parameterName, CharSequence parameterType) '''
	void set«parameterName.toString.capitalizeFirstLetter»(final «parameterType» «parameterName»)
	{
		this.«parameterName» = «parameterName»;
	}
	«parameterType» get«parameterName.toString.capitalizeFirstLetter»() { return «parameterName»; }
	'''

	def camelCase(CharSequence input)
	{
		val strArr = input.toString.replaceAll("\\s", "-").split("-").map(s | s.capitalizeFirstLetter).join('')
		return strArr.substring(0, 1).toLowerCase + strArr.substring(1)
	}
	
	def capitalizeFirstLetter(String s)
	{
		return s.substring(0, 1).toUpperCase() + s.substring(1);
	}
	
	def getGeneratedType (String s)
	{
		return s.camelCase.capitalizeFirstLetter
	}
	
}

