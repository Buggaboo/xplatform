grammar nl.sison.Xplatform with org.eclipse.xtext.common.Terminals

/*
 * 
 * This grammar describes how enum and maps should be defined to generate them
 * 
 * Handy links:
 * * http://pettergraff.blogspot.nl/2009/12/deploying-code-generator-with.html
 * * http://charandeepmatta.com/2012/09/01/how-to-generate-eclipse-plugin-for-your-dsl-written-in-xtext/ - sharing your plugin
 * * http://www.techjava.de/topics/2010/06/extending-xtext-build-participants/ - using "Nature" to distinguish DSLs
 * * http://stackoverflow.com/questions/10917386/linking-xtext-with-stringtemplate-code-generator - run the generator from Main.java
 * * http://wiki.eclipse.org/Xtext/FAQ#How_do_I_load_my_model_in_a_standalone_Java_application.C2.A0.3F - run xtend generation as standalone, e.g. from main method
 * * http://davehofmann.de/blog/?p=101 // - standalone way of setting up the generator
 * * http://koehnlein.blogspot.de/2012/11/xtext-tip-how-do-i-get-guice-injector.html - Guice and standalone dependency injection
 * * http://christiandietrich.wordpress.com/2011/10/15/xtext-calling-the-generator-from-a-context-menu/ - Running "Generate code" from the context menu
 * 
 * IDEA name for the project, plate smasher (boilerplate smasher)
 * IDEA feed vector graphics, generate assets l, m, h, xh, xxh, xxxh, pixel dimensions
 * 
 * -JS (06-Mar-2014)
 * 
 */

generate xplatform "http://www.sison.nl/Xplatform"

/**
 * 
 * Xplatform http call generator parser
 * 
 */

Xplatform:
	platform=Platform
	(	
		resources+=XplatformResourceDefinition | calls+=XplatformCallDefinition	
	)+
;

Platform:
	'platform'
	'{'
		(platforms+=ID '->' whereToGenerate+=STRING)+
	'}'
;


XplatformCallDefinition:
	'call' name=ID ':' method=RESTFUL_METHODS 'from' uri=URI
	('with' 'headers' 'from' 'request' requestHeaders=XplatformHeader
		('and' 'response' responseHeaders=XplatformHeader)?
	)?
	(
		'client' 'expects' jsonToClient=XplatformJson
		('server' 'expects' jsonToServer=XplatformJson)?
	)?
;

URI:
	(ANY_OTHER)+ ('{' uriParameters+=ID '}' (ANY_OTHER)*)?
;

XplatformHeader:
	(name=ID)?
	"'''" 
	'{' (headerKeyValues+=XplatformHeaderKeyValuePair)
		(',' headerKeyValues+=XplatformHeaderKeyValuePair )* (',')? '}'
	"'''"
;

XplatformHeaderKeyValuePair:
	(key=STRING) '=' (value=STRING | value=XPLATFORM_HEADER_PARAMETER)	
;

terminal XPLATFORM_HEADER_PARAMETER:
	'{' ID '}'
;

terminal RESTFUL_METHODS:
	'PUT' | 'POST' | 'GET' | 'DELETE' // TODO HEAD will be automagically generated as well, a body-less response
;

XplatformJson:
	(name=ID)?
	"'''" 
	type=JsonType | metaType=JsonMetaType | composite=JsonObject
	"'''" 
;

terminal JSON_LITERAL_NULL: 'null';

terminal JSON_LITERAL_BOOLEAN:
	'true' | 'false'
;

JsonMetaScalarType:
	'boolean' | 'number' | 'string'
;

JsonMetaArray:
	'[' (metaType=JsonMetaType) ']'
;

JsonMetaType:
	scalar=JsonMetaScalarType | composite=JsonMetaArray
;

JsonCompositeType:
	composite=JsonArray
;

JsonType:
	scalar=JsonScalarType | composite=JsonCompositeType
;

JsonScalarType:
	bool=JSON_LITERAL_BOOLEAN | string=STRING | number=INT ('.' INT)? | null=JSON_LITERAL_NULL 
;

JsonArray:
	('[' (elements+=JsonScalarType) (',' elements+=JsonScalarType )* (',')? ']') |
	('[' (composites+=JsonCompositeType) (',' composites+=JsonCompositeType )* (',')? ']')
;

JsonObject:
	'{'
		(keys+=STRING ':' values+=XplatformJson)
		(','
			keys+=STRING ':' values+=XplatformJson
		)* (',')?
	'}'
;

/**
 * 
 * Xplatform resource generator
 * 
 */
 
XplatformResourceDefinition:
	(resources+=MapInstance | resources+=EnumInstance)+
;


EnumInstance:
	'enum' name=ID
	'{'
		(values += ID) (',' values += ID)* (',')?
	'}'	
;

MapInstance:
	'map' name=ID
	'{'
		(keys+=ID ':' values+=NestedType) (',' keys+=ID ':' values+=NestedType)* (',')?
	'}' // you must have at least one map
;

StringList:
	'[' (values += STRING) (',' values += STRING)* (',')? ']'
;

NestedType:
	STRING | StringList	
;